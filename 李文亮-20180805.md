### 建表原则和列类型选择

* 表的优化

1. 定长和变长分离

如id int, 占4个字节，char(4)占4个字符长度，也是定长，time即每一单元值占的字节是固定的。

核心且常用字段，宜建成定长，放在一张表

而varchar, text ,blob 这种边长字段，适合单放一张表，用主键与核心表关联起来

2. 常用字段和不常用字段要分离

需要结合网站具体的业务来分析，分析字段的查询场景，查询频度低的字段，单拆出来。

3. 在1对需要关联统计的字段上添加冗余字段

* 列类型选择

1. 字段类型优先级 整形>date,time>enum,char>varchar>blob,text列的特点分析

   整形：定长，没有国家/地区之分，没有字符集的差异

   比如tinyint 1,2,3,4,5  <--->  char(1) a,b,c,d,e

   从空间上，都是占1个字节，但是order by排序，前者快

   原因：后者需要考虑字符集和校对集(就是排序规则)

   time:定长，运算快，节省空间，考虑市区写sql时不方便where > '2015-10-12'

   enum:能起约束值得目的，内部用整形来存储，但与char联查时，内部要经历串和值得转化

   char: 定长，考虑字符集和(排序)校对集

   varchar:不定长，要考虑字符集的转换与排序时的校对集，速度慢

   text/blob:无法使用内存临时表(排序等操作只能在磁盘上进行)

   性别：以utf8为例

   char(1) 3个字节长度

   enum('男'’，‘女’) //内部转成数字来存，多了一个转换过程

   tinyint() //0 1 2 定长1个字节

2. 够用就行，不要慷慨，如smallint,varchar(n)

   原因：大的字段浪费内存影响速度

   以年龄为例，tinyint unsigned not null，可以存储255岁，够用，用int浪费3个字节，以varchar(10),varchar(300)存储的内容相同，但在表联查时，varchar(300)要花更多内存

3. 尽量避免使用NULL

   原因：null不利于索引，要用特殊的字节来标注

   在磁盘上占据的空间其实更大(mysql5.6里关于null已经做了优化，但查询仍然布标)

### btree索引原理

breen=balance tree，基于平衡树的数据结构

mysql内有两种索引,btree索引和hash索引

![](https://test-1253124993.cos.ap-beijing.myqcloud.com/IMG_2379.PNG)

### hash索引

只能在memory表内使用，就是内存里

表就是放在内存里的，如果关机，内存全丢

hash索引的查询速度很快，理论查询查询时间复杂度为o(1)，无论有多少条，一下子就能找到

缺点：

1. hash函数计算后的结果是随机的
2. 无法进行范围进行优化
3. 无法进行前缀索引，比如在btree中，field列的值hello world，并加索引查询xx-helloworld，自然可以利用索引，xx-hello也可以利用索引(左前索引)，因为hash("helloworld")和hash("hello")两者的关系仍为随机
4. 排序也无法优化。
5. 必须回行，就是说通过索引拿到数据位置，必须回到表中取数据.

### 索引经典题目

建立联合索引c1,c2,c3,c4

1. where c1=1 and c2=2 and c4>3 and c3=1   c1,c2,c3,c4都可以用到索引，c3,c4语义是相同的
2. where c1=1 and c2=3 and c4=2 order by c3   c1,c2用在查询，c3用在排序
3. where c1=1 and c4=2 group by c2,c3  c1用在查询，c2,c3用不上，顺序不对
4. where c1=1 and c5=5 order by c2,c3   c1用在查询，c2,c3用在排序
5. where c1=1 and c2=2 and c5>2 order by c2,c3  c1,c2用在查询，c3用在排序，c2已经准确匹配了，所以此处不会用在排序了

### 聚簇索引和非聚簇索引

innodb和myisam都用的是btree索引

* myisam

  假如创建good表,myisam会创建三张表

  ```
  good.frm	结构表
  good.myd	数据表
  good.myi	索引表
  ```

  这种索引和数据分开的，非聚簇索引，先找到索引树，然后去磁盘拿数据

* innodb

  创建一个索引树，叶子节点上带有数据，找到这个树后可以直接拿到数据，这种索引叫聚簇索引

  ![](https://test-1253124993.cos.ap-beijing.myqcloud.com/IMG_2384.PNG)

* 对比

  myisam的索引指向行在磁盘的位置

  innodb的次级索引指向对主键的引用：id索引下面带有数据，其他索引叶子存储主键，次级索引找到后，指向主键索引

* notice

  对于innodb而言

  1. 主键索引既存储索引值，又在叶子中存储行的数据
  2. 如果没有主键(primary key)，则会unique key做主键
  3. 如果没有unique，则系统生成一个内部rowid做主键
  4. 像innodb中，主键的索引结构中，既存储了主键值，又存储了行数据，这种结构成为聚簇索引

  聚簇索引

  * 优势：根据主键查询条目比较少时，不用回行，数据就在主键节点下
  * 缺点：如果碰到不规则数据插入时，造成频繁的页分裂

### 聚簇索引的页分裂

聚簇索引中，N行形成一个页，当不规律插入时，不断造成页分裂，插件速度比较慢

聚簇索引中，id在节点上下面带有沉重的数据，当数据主键离散比较大，造成节点来回移动比较频繁

### 索引覆盖

索引覆盖是指：如果查询的列恰好是索引的一部分，那么查询只需要在索引文件上进行，不需要回行到磁盘再找数据，这样的查询速度非常快，称为索引覆盖。

### 理想的索引

1. 查询频繁
2. 区分度高
3. 长度小
4. 尽量覆盖常用查询字段


### 修复表

1. 表的引擎为innodb，可以

   ```
   alter table xxx engine innodb
   ```

2. optimize table 表名

   注意

   1. 修复表的数据及索引会把所有的数据文件重新整理一遍，是指对其，这个过程，如果表的行数比较大，也是非常耗资源的操作，所以不能频繁修复
   2. 如果表的update操作很频繁，可以按照周/月来修复，如果不频繁，可以按照更长的周期来修复

### 查询大原则

1. 算起来的语句的时间花在哪儿

   答：等待时间，执行时间

   这两个时间并非孤立的，如果单条语句执行的快了，对其他语句的锁定也就少了，所以我们来分析如何降低执行时间。

2. sql的执行时间又花在哪儿

   a.查找 -> 沿着索引查找慢者可能全表扫描

   b.取出 -> 查到行后，把数据取出来(sending data)

3. 如何查询快

   a.查询的快-联合索引的顺序，区分度，长度

   b.取的快，索引覆盖

   c.传输的少，更少的行与列

4. 切分查询：按照数据拆分多次

   例：插入10000行数据，每1000条为单位，插件

   分解查询：按逻辑把多张表链接查询氛围多个简单sql

5. sql语句的优化思路

   不查->少查->高效的查

   不查：通过业务逻辑来计算

   比如论坛的注册会员数，我们可以根据前3个月统计的每天注册数，用程序来估算。

   少查：尽量精确数据，少取行，我们观察新闻网站，评论内容等，一般一次性取列表，10-30条左右

   必须要查尽量走在索引上查询行

   取时，取尽量少的列

   比如，select * from tablea

   比如 select * from tablea,tableb